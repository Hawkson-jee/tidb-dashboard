// Copyright 2022 PingCAP, Inc. Licensed under Apache-2.0.

package download

import (
	"errors"

	"github.com/golang-jwt/jwt"
	"github.com/gtank/cryptopasta"
	"github.com/joomcode/errorx"

	"github.com/pingcap/tidb-dashboard/util/nocopy"
)

type Controller struct {
	nocopy.NoCopy
	secret []byte
}

func NewController() *Controller {
	return &Controller{
		secret: cryptopasta.NewHMACKey()[:],
	}
}

// Secret returns the secret used to sign the token.
// This function is concurrent-safe.
func (s *Controller) Secret() []byte {
	return s.secret
}

// GetDownloadToken generates a token contains arbitrary data, for downloading purpose.
// The token is safe to be passed back later without an authentication check so that it can be used to start
// a browser download easily.
// This function is concurrent-safe.
func (s *Controller) GetDownloadToken(claims jwt.Claims) (string, error) {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenSigned, err := token.SignedString(s.secret)
	if err != nil {
		return "", err
	}
	return tokenSigned, nil
}

// HandleDownloadToken parses and checks a download token generated by GetDownloadToken.
// If an expiration time is specified in the original token, it will be checked.
// WARN: The audience and the issuer are never checked by this function. You must check manually if needed.
// This function is concurrent-safe.
func (s *Controller) HandleDownloadToken(tokenString string, outputClaims jwt.Claims) error {
	token, err := jwt.ParseWithClaims(
		tokenString,
		outputClaims,
		func(token *jwt.Token) (interface{}, error) {
			return s.secret, nil
		})
	if token != nil {
		if token.Valid {
			return nil
		}
	}
	var ve *jwt.ValidationError
	if errors.As(err, &ve) && ve.Errors&jwt.ValidationErrorExpired != 0 {
		return errorx.Decorate(err, "download token is expired")
	}
	return errorx.Decorate(err, "download token is invalid")
}
